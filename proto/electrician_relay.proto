syntax = "proto3";

import "google/protobuf/timestamp.proto";

package electrician;

option go_package = "github.com/joeydtaylor/electrician/pkg/internal/relay";

// ---------- Core ----------

message WrappedPayload {
  string id = 1;
  google.protobuf.Timestamp timestamp = 2;

  // The actual application payload (opaque to relay).
  bytes payload = 3;

  // Per-message metadata (may be omitted in streaming if StreamOpen.defaults is set).
  MessageMetadata metadata = 4;

  // Per-message error info (optional).
  ErrorInfo error_info = 5;

  // NEW: stream-local monotonic sequence number for correlation/ordering.
  uint64 seq = 6;
}

message ErrorInfo {
  int32 code = 1;
  string message = 2;
  repeated string details = 3;
}

message MessageMetadata {
  map<string, string> headers = 1;
  string content_type = 2;
  VersionInfo version = 3;
  PerformanceOptions performance = 4;
  string trace_id = 5;
  int32 priority = 6;

  // Existing content/transport crypto.
  SecurityOptions security = 7;

  // Auth hints for resource servers; server config may override.
  AuthenticationOptions authentication = 8;

  // Populated by receiver after auth; no raw tokens.
  AuthContext auth_context = 9;
}

message SecurityOptions {
  bool enabled = 1;
  EncryptionSuite suite = 2;
}

enum EncryptionSuite {
  ENCRYPTION_NONE = 0;
  ENCRYPTION_AES_GCM = 1;
}

message VersionInfo {
  int32 major = 1;
  int32 minor = 2;
}

message PerformanceOptions {
  bool use_compression = 1;
  CompressionAlgorithm compression_algorithm = 2;
  int32 compression_level = 3;
}

enum CompressionAlgorithm {
  COMPRESS_NONE = 0;
  COMPRESS_DEFLATE = 1;
  COMPRESS_SNAPPY = 2;
  COMPRESS_ZSTD = 3;
  COMPRESS_BROTLI = 4;
  COMPRESS_LZ4 = 5;
}

// ---------- Auth (optional) ----------

enum AuthMode {
  AUTH_MODE_UNSPECIFIED = 0;
  AUTH_NONE = 1;        // No app-layer auth (e.g., mTLS-only)
  AUTH_OAUTH2 = 2;      // Bearer token in "authorization" metadata
  AUTH_MUTUAL_TLS = 3;  // Client cert at transport layer
}

message AuthenticationOptions {
  bool enabled = 1;          // If false, treat as AUTH_NONE
  AuthMode mode = 2;         // Expected mode
  OAuth2Options oauth2 = 3;  // OAuth2/JWT/introspection (optional)
  MTLSOptions mtls = 4;      // mTLS expectations (optional)
}

message OAuth2Options {
  bool accept_jwt = 1;              // Validate JWT locally via JWKS
  bool accept_introspection = 2;    // RFC 7662 for opaque tokens

  // JWT validation hints (optional)
  string issuer = 3;                // Expected iss
  string jwks_uri = 4;              // Override JWKS URI; else discover
  repeated string required_audience = 5;
  repeated string required_scopes = 6;

  // Introspection config (optional)
  string introspection_url = 7;
  string introspection_auth_type = 8;   // "basic" | "bearer" | "none"
  string introspection_client_id = 9;
  string introspection_client_secret = 10;
  string introspection_bearer_token = 11;

  // Behavior (optional)
  bool forward_bearer_token = 12;       // Default false
  string forward_metadata_key = 13;     // e.g., "x-forwarded-authorization"

  // Caching hints (seconds, optional)
  int32 jwks_cache_seconds = 14;         // e.g., 300
  int32 introspection_cache_seconds = 15; // e.g., 60
}

message MTLSOptions {
  repeated string allowed_principals = 1; // CN/SAN/SPIFFE
  string trust_domain = 2;                // Impl-specific
}

// Auth facts emitted post-validation (no raw tokens).
message AuthContext {
  AuthMode mode = 1;
  bool authenticated = 2;
  string principal = 3;                 // Canonical subject
  string subject = 4;                   // Token sub or cert subject
  string client_id = 5;                 // OAuth2 client_id if present
  repeated string scopes = 6;
  map<string, string> claims = 7;       // Curated claim set (stringified)
  google.protobuf.Timestamp expires_at = 8;
  string issuer = 9;
  repeated string audience = 10;
  string token_id = 11;                 // JWT jti if present
}

// ---------- Streaming control (no extra RPCs) ----------

enum AckMode {
  ACK_MODE_UNSPECIFIED = 0;

  // Send an ack for every payload (highest overhead, strongest per-item feedback).
  ACK_PER_MESSAGE = 1;

  // Send acks periodically (every ack_every_n payloads). Receiver may also ack on timer.
  ACK_BATCH = 2;

  // No acks (fire-and-forget).
  ACK_NONE = 3;
}

message StreamOpen {
  // Optional stream ID from client; receiver can echo it back in acks.
  string stream_id = 1;

  // Defaults applied to subsequent WrappedPayload.metadata when the payload metadata is omitted.
  MessageMetadata defaults = 2;

  // Acknowledgment policy.
  AckMode ack_mode = 3;
  uint32 ack_every_n = 4;     // used when ACK_BATCH (0 => receiver chooses)
  uint32 max_in_flight = 5;   // advisory backpressure hint (0 => receiver chooses)

  // If true, client intends to omit WrappedPayload.metadata on most messages.
  bool omit_payload_metadata = 6;
}

message StreamClose {
  string reason = 1;
}

// Envelope used by StreamReceive: first message SHOULD be StreamOpen, then payloads, optional close.
message RelayEnvelope {
  oneof msg {
    StreamOpen open = 1;
    WrappedPayload payload = 2;
    StreamClose close = 3;
  }
}

// ---------- Service ----------

service RelayService {
  // Unary stays the same (simple request/ack).
  rpc Receive(WrappedPayload) returns (StreamAcknowledgment);

  // Streaming now uses the envelope to avoid per-message repeated metadata and allow ack batching.
  rpc StreamReceive(stream RelayEnvelope) returns (stream StreamAcknowledgment);
}

// Ack supports per-message and batch modes.
message StreamAcknowledgment {
  bool success = 1;
  string message = 2;
  map<string, string> metadata = 3;

  // Correlation (set when known)
  string stream_id = 4;
  string id = 5;      // echoes WrappedPayload.id when ACK_PER_MESSAGE
  uint64 seq = 6;     // echoes WrappedPayload.seq when ACK_PER_MESSAGE

  // Structured status (optional)
  int32 code = 7;     // app-defined
  bool retryable = 8;

  // Batch ack fields (used when ACK_BATCH)
  uint64 last_seq = 9;
  uint32 ok_count = 10;
  uint32 err_count = 11;
}
